#pragma once
#include "libevent_header.h"

//错误，超时 （连接断开会进入）
static void event_cb(bufferevent* be, short events, void* arg)
{
	std::cout << "[E]" << std::endl;
	
	if (events & BEV_EVENT_TIMEOUT && events & BEV_EVENT_READING)
	{
		std::cout << "BEV_EVENT_READING BEV_EVENT_TIMEOUT" << std::endl;
		//bufferevent_enable(be,EV_READ); //读取超时时间发生后，数据读取停止
		bufferevent_free(be);
	}
	else if (events & BEV_EVENT_ERROR)
	{
		bufferevent_free(be);
	}
	else
	{
		std::cout << "OTHERS" << std::endl;
	}
}

static void write_cb(bufferevent* be, void* arg)
{
	std::cout << "[W]" << std::endl;
}

static void read_cb(bufferevent* be, void* arg)
{
	std::cout << "[R]" << std::endl;
	char data[1024] = { 0 };
	//读取输入缓冲数据
	int len = bufferevent_read(be, data, sizeof(data) - 1);
	std::cout << "[" << data << "]" << std::endl;
	if (len <= 0)return;
	if (strstr(data, "quit") != NULL)
	{
		std::cout << "quit";
		//退出并关闭socket BEV_OPT_CLOSE_ON_FREE
		bufferevent_free(be);
	}
	//发送数据 写入到输出缓冲
	bufferevent_write(be, "OKKKKKKKKsss", 10); //每次你发送数据，当你数据缓存区的数据随着发送，减少到低水位时，调用写入回调函数

}


static void listen_cb(evconnlistener* ev, evutil_socket_t s, sockaddr* sin, int slen, void* arg)
{
	std::cout << "listen_cb" << std::endl;
	event_base* base = (event_base*)arg;
	bufferevent* be = bufferevent_socket_new(base, s, BEV_OPT_CLOSE_ON_FREE);
	
	//设置事件使能 ，读写
	bufferevent_enable(be, EV_READ | EV_WRITE);

	// 设置水位,默认0，0
	bufferevent_setwatermark(be, EV_READ, 5, 10);
	bufferevent_setwatermark(be, EV_WRITE,
		50,	//低水位 0就是无限制 默认是0 缓冲数据低于5 写入回调被调用，
		0	//高水位无效
	);

	//超时时间的设置
	timeval t1 = { 3,0 };
	bufferevent_set_timeouts(be, &t1, 0);

	//设置回调函数
	bufferevent_setcb(be, read_cb, write_cb, event_cb, base);
}


static void c4_3_buffer_server_test()
{
#ifdef _WIN32 
	//初始化socket库
	WSADATA wsa;
	WSAStartup(MAKEWORD(2, 2), &wsa);
#else
	//忽略管道信号，发送数据给已关闭的socket
	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		return 1;
#endif

	event_base* base = event_base_new();
	//创建网络服务器

	//设定监听的端口和地址
	sockaddr_in sin;
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(5001);

	evconnlistener* ev = evconnlistener_new_bind(base,
		listen_cb,		//回调函数
		base,			//回调函数的参数arg
		LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE,
		10,				//listen back
		(sockaddr*)&sin,
		sizeof(sin)
	);

	//进入事件主循环
	event_base_dispatch(base);
	evconnlistener_free(ev);
	event_base_free(base);

};

